# Intro to Comp Sys - Homework 1

## Problem 1 - Interrupts

### Describe what a hardware interrupt, a trap, and an exception is, and list/justify as many differences as you can identify between any two of those.

1. A hardware interrupt is an asynchronous signal from a hardware device indicating that the device requires attention.
2. A trap is a synchronous transfer of control to the operating system. Traps are used for system calls and can be generated by either the user or system.
3. An exception is a synchronous event that occurs due to errors or unusual conditions during instruction execution. Exceptions occur when the processor detects errors and invokes an exception handler to deal with it.
<div align="center">

|Topic|Hardware Interrupt|Trap|
|:-------:|:-------------------:|:------:|
|Timing|Asynchronous|Synchronous|
|Cause|Hardware Event|Software Event|
|Trigger|External Device/Timer|Program Instruction|
|Return Exception|Can resume program execution|Can resume after OS service|
|Priority|Can be masked by CPU|Not Masked|

</div>

## Problem 2 - Direct Memory Access
### 1. Assume that a Network Card has data to transfer with the end goal to save the data in DRAM. Describe in detail the steps that need to be taken by the CPU, the Network Card, the user program and the OS in order to coordinate the transfer (type of interrupts, register modifications, mode shifts, etc etc).
The steps needed to coordinate the data transfer are as follows:
1. The NIC buffers incoming data and raises a hardware interrupt.
2. The CPU handles the interrupt by having the interrupt handler (ISR) in the NIC driver read the NIC registers, and acknowledges the interrupt.
    - If we are using DMA, the NIC transfers directly to DRAM. Otherwise, the CPU copies the data through Programmed I/O (PIO).
3. The OS processes the data through the kernel network stack, and can copy the data to user-space for it to be used by a waiting process.
4. The OS schedules the user program and switches from kernel to user mode.
5. The user receives the data from the kernel buffer and processes the data.

### 2. How does the CPU know when memory operations are complete
The CPU knows when the memory operation is complete through the use of interrupts and handshakes generated after the memory is ready. This includes interrupts from the memory controller after the DMA transfer is done, ready/wait signals load/store buffers, and polling.

### 3. The CPU is allowed to execute other programs while the DMA controller is transferring data. Does this process interfere at any point during its life-cycle with the execution of user programs? If so,describe when and how interference(s) are caused.
It is possible for there to be interference with user programs. Some potential areas for interference include:
1. The memory bus needing to be used by both the CPU and DMA. If the DMA is sending data over the bus, the CPU needs to wait for the bus to be clear before continuing.
2. Interrupts generated by the DMA controller can force the CPU to deal with the interrupt, which would require pausing the execution of user programs.
3. If the CPU is working with cached data that is being transferred by the DMA controller, the CPU may need to flush registers, thus adding overhead.
4. Peripheral I/O can add overhead if a user program is working with a peripheral that is also needed for the DMA Transfer. 

## Problem 3 - Familiarizing yourself with Linux
### 1. Which instruction gives you your default shell?
```echo $SHELL``` gives you the default shell.

### 2. Which command gives you the current shell?
```echo $0``` gives you the current shell?

### 3. Which instruction gives you the process ID of your current shell?
```ps $$``` or ```echo $$``` will give you the process ID of the current shell.

### 4. Which instructions do you need to use to switch from your default shell to another shell and back to your default shell?
- ```bash``` will switch to a bash shell.
- ```zsh``` will switch to a zsh shell.
- ```fish``` will switch to a fish shell.
- ```dash``` will switch to a dash shell.
- ```exit``` will close the current shell and return to the previous shell.

### 5. Open two different shells in two different terminals, get information from both using either ```ls -some_flag``` or ```ps -some_flag``` or ```htop``` command, and then use another command to terminate the older fo the two shells from the newer shell. Show a screenshot of both terminals with the executed commands.
1. From older bash shell
```
[joshg@Hypr:~]$ echo $0
bash

[joshg@Hypr:~]$ ps $$
    PID TTY      STAT   TIME COMMAND
   2705 pts/2    S      0:00 bash
```

2. From newer zsh shell
```
┌─[joshg@Hypr] - [~] - [Thu Feb 20, 15:06]
└─[$] <> echo $0
/run/current-system/sw/bin/zsh
┌─[joshg@Hypr] - [~] - [Thu Feb 20, 15:06]
└─[$] <> ps $$  
    PID TTY      STAT   TIME COMMAND
   3387 pts/1    Ss     0:00 /run/current-system/sw/bin/zsh
┌─[joshg@Hypr] - [~] - [Thu Feb 20, 15:07]
└─[$] <> ps -eo pid,lstart,cmd | grep -E 'bash|zsh'
   2426 Thu Feb 20 15:01:11 2025 /run/current-system/sw/bin/zsh
   2625 Thu Feb 20 15:01:13 2025 /run/current-system/sw/bin/zsh
   2705 Thu Feb 20 15:01:19 2025 bash
   3387 Thu Feb 20 15:06:43 2025 /run/current-system/sw/bin/zsh
   3557 Thu Feb 20 15:07:28 2025 grep --color=auto --exclude-dir=.bzr --exclude-dir=CVS --exclude-dir=.git --exclude-dir=.hg --exclude-dir=.svn --exclude-dir=.idea --exclude-dir=.tox -E bash|zsh
┌─[joshg@Hypr] - [~] - [Thu Feb 20, 15:07]
└─[$] <> kill -9 2705
┌─[joshg@Hypr] - [~] - [Thu Feb 20, 15:12]
└─[$] <> ps -eo pid,lstart,cmd | grep -E 'bash|zsh'
   2426 Thu Feb 20 15:01:11 2025 /run/current-system/sw/bin/zsh
   2625 Thu Feb 20 15:01:13 2025 /run/current-system/sw/bin/zsh
   3387 Thu Feb 20 15:06:43 2025 /run/current-system/sw/bin/zsh
   4178 Thu Feb 20 15:09:18 2025 /run/current-system/sw/bin/zsh
   5819 Thu Feb 20 15:10:58 2025 /run/current-system/sw/bin/zsh
   6489 Thu Feb 20 15:13:05 2025 grep --color=auto --exclude-dir=.bzr --exclude-dir=CVS --exclude-dir=.git --exclude-dir=.hg --exclude-dir=.svn --exclude-dir=.idea --exclude-dir=.tox -E bash|zsh
┌─[joshg@Hypr] - [~] - [Thu Feb 20, 15:13]
└─[$] <> 
```
**NOTE:** After killing the bash process, we can no longer find that process with the ```ps -eo pid, lstart,cmd | grep -E 'bash|zsh'``` command

## Problem 4 - Altering simple instruction cycle to incorporate interrupts. 
### In a simple computing machine let all memory addresses lower than or equal to 100 belong to the kernel space, and those higher than 100 belong to the user space. Suppose that the mode register has value 0 when the processor is in the kernel mode.

### 1. Which states/phases of handling an instruction must be modified to address the possibility of memory violations or timer interrupts?

### 2. What if the above two events occur almost simultaneously? How do you imagine that the OS prioritizes to handle these events?


